# coding: utf-8

"""
    Invoices

    Invoices describe how much a customer owes for his subscription. Invoices are created for recurring charges, one time charges including any prorated adjustments.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class ListAllInvoicesResponseInvoicesInner(BaseModel):
    """
    ListAllInvoicesResponseInvoicesInner
    """ # noqa: E501
    invoice_id: Optional[StrictStr] = Field(default=None, description="Unique ID generated for an invoice.")
    number: Optional[StrictStr] = Field(default=None, description="Unique invoice number (starts with INV) generated for an invoice which will be used to display in interface and invoices.")
    status: Optional[StrictStr] = Field(default=None, description="Status of the invoice. It can be <code>paid</code>, <code>sent</code>, <code>overdue</code>, <code>partially_paid</code> or <code>void</code>.")
    invoice_date: Optional[StrictStr] = Field(default=None, description="The date on which the invoice is raised.")
    due_date: Optional[StrictStr] = Field(default=None, description="Date on which the invoice is due. If the invoice is not fully paid on or before this date, the status of the invoice will be changed to <code>overdue</code>. If the invoice is only partially paid, its status will be <code>partially_paid</code>.")
    customer_id: Optional[StrictStr] = Field(default=None, description="Customer ID of the customer to whom the invoice is raised.")
    customer_name: Optional[StrictStr] = Field(default=None, description="Name of the customer to whom the invoice is raised.")
    email: Optional[StrictStr] = Field(default=None, description="Email address of the customer.")
    balance: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The unpaid amount of an invoice.")
    total: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Total amount to be paid for the invoice. This would be the sum of individual costs of all items involved in the invoice. Total is determined only after customer credits (if any) are applied.")
    currency_code: Optional[StrictStr] = Field(default=None, description="The customer's currency code.")
    currency_symbol: Optional[StrictStr] = Field(default=None, description="The customer's currency symbol.")
    has_attachment: Optional[Any] = Field(default=None, description="Denotes whether a customer has any attachments associated with it.")
    created_time: Optional[StrictStr] = Field(default=None, description="Time when the invoice was created.")
    updated_time: Optional[StrictStr] = Field(default=None, description="Time when the invoice details were last updated.")
    __properties: ClassVar[List[str]] = ["invoice_id", "number", "status", "invoice_date", "due_date", "customer_id", "customer_name", "email", "balance", "total", "currency_code", "currency_symbol", "has_attachment", "created_time", "updated_time"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ListAllInvoicesResponseInvoicesInner from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if has_attachment (nullable) is None
        # and model_fields_set contains the field
        if self.has_attachment is None and "has_attachment" in self.model_fields_set:
            _dict['has_attachment'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ListAllInvoicesResponseInvoicesInner from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "invoice_id": obj.get("invoice_id"),
            "number": obj.get("number"),
            "status": obj.get("status"),
            "invoice_date": obj.get("invoice_date"),
            "due_date": obj.get("due_date"),
            "customer_id": obj.get("customer_id"),
            "customer_name": obj.get("customer_name"),
            "email": obj.get("email"),
            "balance": obj.get("balance"),
            "total": obj.get("total"),
            "currency_code": obj.get("currency_code"),
            "currency_symbol": obj.get("currency_symbol"),
            "has_attachment": obj.get("has_attachment"),
            "created_time": obj.get("created_time"),
            "updated_time": obj.get("updated_time")
        })
        return _obj


